#include "includes.h"
#include "lib/com/dcom/dcom.h"
#include "bin/default/librpc/gen_ndr/com_wmi.h"
#include "librpc/rpc/dcerpc.h"
/* DCOM proxy for IWbemServices generated by pidl */


static WERROR dcom_proxy_IWbemServices_OpenNamespace(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strNamespace, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemServices **ppWorkingNamespace, struct IWbemCallResult **ppResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct OpenNamespace r;
	struct MInterfacePointer* ppWorkingNamespace_mi = NULL;
	struct MInterfacePointer* ppResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strNamespace = strNamespace;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppWorkingNamespace) {
		if (*ppWorkingNamespace) {
			r.in.ppWorkingNamespace = &ppWorkingNamespace_mi;
			ppWorkingNamespace_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppWorkingNamespace_mi->obj, (struct IUnknown*)(*ppWorkingNamespace)));
		}
	}
	if (ppResult) {
		if (*ppResult) {
			r.in.ppResult = &ppResult_mi;
			ppResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppResult_mi->obj, (struct IUnknown*)(*ppResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(OpenNamespace, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_OPENNAMESPACE, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(OpenNamespace, &r);
	}
#endif

	if (r.out.ppWorkingNamespace) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppWorkingNamespace, *r.out.ppWorkingNamespace));
	}
	if (r.out.ppResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppResult, *r.out.ppResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_CancelAsyncCall(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct IWbemObjectSink *pSink)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct CancelAsyncCall r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.pSink = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pSink) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pSink->obj, (struct IUnknown*)pSink));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(CancelAsyncCall, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_CANCELASYNCCALL, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(CancelAsyncCall, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_QueryObjectSink(struct IWbemServices *d, TALLOC_CTX *mem_ctx, int32_t lFlags, struct IWbemObjectSink **ppResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct QueryObjectSink r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lFlags = lFlags;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(QueryObjectSink, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_QUERYOBJECTSINK, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(QueryObjectSink, &r);
	}
#endif

	if (r.out.ppResponseHandler) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppResponseHandler, *r.out.ppResponseHandler));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_GetObject(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject **ppObject, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetObject r;
	struct MInterfacePointer* ppObject_mi = NULL;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppObject) {
		if (*ppObject) {
			r.in.ppObject = &ppObject_mi;
			ppObject_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppObject_mi->obj, (struct IUnknown*)(*ppObject)));
		}
	}
	if (ppCallResult) {
		if (*ppCallResult) {
			r.in.ppCallResult = &ppCallResult_mi;
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetObject, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_GETOBJECT, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetObject, &r);
	}
#endif

	if (r.out.ppObject) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppObject, *r.out.ppObject));
	}
	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_GetObjectAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetObjectAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetObjectAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_GETOBJECTASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetObjectAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_PutClass(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct IWbemClassObject *pObject, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct PutClass r;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.pObject = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pObject) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pObject->obj, (struct IUnknown*)pObject));
	}
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppCallResult) {
		if (*ppCallResult) {
			r.in.ppCallResult = &ppCallResult_mi;
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(PutClass, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_PUTCLASS, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(PutClass, &r);
	}
#endif

	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_PutClassAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct IWbemClassObject *pObject, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct PutClassAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.pObject = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pObject) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pObject->obj, (struct IUnknown*)pObject));
	}
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(PutClassAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_PUTCLASSASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(PutClassAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_DeleteClass(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strClass, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct DeleteClass r;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strClass = strClass;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppCallResult) {
		if (*ppCallResult) {
			r.in.ppCallResult = &ppCallResult_mi;
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(DeleteClass, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_DELETECLASS, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(DeleteClass, &r);
	}
#endif

	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_DeleteClassAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strClass, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct DeleteClassAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strClass = strClass;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(DeleteClassAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_DELETECLASSASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(DeleteClassAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_CreateClassEnum(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strSuperclass, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct CreateClassEnum r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strSuperclass = strSuperclass;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(CreateClassEnum, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_CREATECLASSENUM, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(CreateClassEnum, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_CreateClassEnumAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strSuperclass, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct CreateClassEnumAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strSuperclass = strSuperclass;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(CreateClassEnumAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_CREATECLASSENUMASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(CreateClassEnumAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_PutInstance(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct IWbemClassObject *pInst, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct PutInstance r;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.pInst = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pInst) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pInst->obj, (struct IUnknown*)pInst));
	}
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppCallResult) {
		if (*ppCallResult) {
			r.in.ppCallResult = &ppCallResult_mi;
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(PutInstance, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_PUTINSTANCE, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(PutInstance, &r);
	}
#endif

	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_PutInstanceAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct IWbemClassObject *pInst, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct PutInstanceAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.pInst = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pInst) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pInst->obj, (struct IUnknown*)pInst));
	}
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(PutInstanceAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_PUTINSTANCEASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(PutInstanceAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_DeleteInstance(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct DeleteInstance r;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	if (ppCallResult) {
		if (*ppCallResult) {
			r.in.ppCallResult = &ppCallResult_mi;
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(DeleteInstance, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_DELETEINSTANCE, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(DeleteInstance, &r);
	}
#endif

	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_DeleteInstanceAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct DeleteInstanceAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(DeleteInstanceAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_DELETEINSTANCEASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(DeleteInstanceAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_CreateInstanceEnum(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strFilter, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct CreateInstanceEnum r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strFilter = strFilter;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(CreateInstanceEnum, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_CREATEINSTANCEENUM, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(CreateInstanceEnum, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_CreateInstanceEnumAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strSuperClass, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct CreateInstanceEnumAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strSuperClass = strSuperClass;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(CreateInstanceEnumAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_CREATEINSTANCEENUMASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(CreateInstanceEnumAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecQuery(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strQueryLanguage, struct BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecQuery r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strQueryLanguage = strQueryLanguage;
	r.in.strQuery = strQuery;
	r.in.lFlags = lFlags;
	r.in.pCtx = NULL;
	if (pCtx) {
		r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.out.ORPCthat = talloc_zero(mem_ctx, struct ORPCTHAT);
#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecQuery, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECQUERY, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecQuery, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecQueryAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strQueryLanguage, struct BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecQueryAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strQueryLanguage = strQueryLanguage;
	r.in.strQuery = strQuery;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecQueryAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECQUERYASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecQueryAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecNotificationQuery(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strQueryLanguage, struct BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecNotificationQuery r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strQueryLanguage = strQueryLanguage;
	r.in.strQuery = strQuery;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecNotificationQuery, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECNOTIFICATIONQUERY, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecNotificationQuery, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecNotificationQueryAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strQueryLanguage, struct BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecNotificationQueryAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strQueryLanguage = strQueryLanguage;
	r.in.strQuery = strQuery;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecNotificationQueryAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECNOTIFICATIONQUERYASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecNotificationQueryAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecMethod(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, struct BSTR strMethodName, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject *pInParams, struct IWbemClassObject **ppOutParams, struct IWbemCallResult **ppCallResult)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecMethod r;
	struct MInterfacePointer* ppOutParams_mi = NULL;
	struct MInterfacePointer* ppCallResult_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.strMethodName = strMethodName;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pInParams = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pInParams) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pInParams->obj, (struct IUnknown*)pInParams));
	}
	if (ppOutParams) {
		r.in.ppOutParams = &ppOutParams_mi;
		if (*ppOutParams) {
			ppOutParams_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppOutParams_mi->obj, (struct IUnknown*)(*ppOutParams)));
		}
	}
	if (ppCallResult) {
		r.in.ppCallResult = &ppCallResult_mi;
		if (*ppCallResult) {
			ppCallResult_mi = talloc_zero(mem_ctx, struct MInterfacePointer);
			WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &ppCallResult_mi->obj, (struct IUnknown*)(*ppCallResult)));
		}
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecMethod, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECMETHOD, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecMethod, &r);
	}
#endif

	if (r.out.ppOutParams) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppOutParams, *r.out.ppOutParams));
	}
	if (r.out.ppCallResult) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppCallResult, *r.out.ppCallResult));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemServices_ExecMethodAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx, struct BSTR strObjectPath, struct BSTR strMethodName, uint32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject *pInParams, struct IWbemObjectSink *pResponseHandler)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct ExecMethodAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.strObjectPath = strObjectPath;
	r.in.strMethodName = strMethodName;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}
	r.in.pInParams = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pInParams) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pInParams->obj, (struct IUnknown*)pInParams));
	}
	r.in.pResponseHandler = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pResponseHandler) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pResponseHandler->obj, (struct IUnknown*)pResponseHandler));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(ExecMethodAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemServices, NDR_EXECMETHODASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(ExecMethodAsync, &r);
	}
#endif


	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemServices(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemServices(TALLOC_CTX *ctx)
{
	struct IWbemServices_vtable *proxy_vtable = talloc(ctx, struct IWbemServices_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->OpenNamespace = dcom_proxy_IWbemServices_OpenNamespace;
	proxy_vtable->CancelAsyncCall = dcom_proxy_IWbemServices_CancelAsyncCall;
	proxy_vtable->QueryObjectSink = dcom_proxy_IWbemServices_QueryObjectSink;
	proxy_vtable->GetObject = dcom_proxy_IWbemServices_GetObject;
	proxy_vtable->GetObjectAsync = dcom_proxy_IWbemServices_GetObjectAsync;
	proxy_vtable->PutClass = dcom_proxy_IWbemServices_PutClass;
	proxy_vtable->PutClassAsync = dcom_proxy_IWbemServices_PutClassAsync;
	proxy_vtable->DeleteClass = dcom_proxy_IWbemServices_DeleteClass;
	proxy_vtable->DeleteClassAsync = dcom_proxy_IWbemServices_DeleteClassAsync;
	proxy_vtable->CreateClassEnum = dcom_proxy_IWbemServices_CreateClassEnum;
	proxy_vtable->CreateClassEnumAsync = dcom_proxy_IWbemServices_CreateClassEnumAsync;
	proxy_vtable->PutInstance = dcom_proxy_IWbemServices_PutInstance;
	proxy_vtable->PutInstanceAsync = dcom_proxy_IWbemServices_PutInstanceAsync;
	proxy_vtable->DeleteInstance = dcom_proxy_IWbemServices_DeleteInstance;
	proxy_vtable->DeleteInstanceAsync = dcom_proxy_IWbemServices_DeleteInstanceAsync;
	proxy_vtable->CreateInstanceEnum = dcom_proxy_IWbemServices_CreateInstanceEnum;
	proxy_vtable->CreateInstanceEnumAsync = dcom_proxy_IWbemServices_CreateInstanceEnumAsync;
	proxy_vtable->ExecQuery = dcom_proxy_IWbemServices_ExecQuery;
	proxy_vtable->ExecQueryAsync = dcom_proxy_IWbemServices_ExecQueryAsync;
	proxy_vtable->ExecNotificationQuery = dcom_proxy_IWbemServices_ExecNotificationQuery;
	proxy_vtable->ExecNotificationQueryAsync = dcom_proxy_IWbemServices_ExecNotificationQueryAsync;
	proxy_vtable->ExecMethod = dcom_proxy_IWbemServices_ExecMethod;
	proxy_vtable->ExecMethodAsync = dcom_proxy_IWbemServices_ExecMethodAsync;

	proxy_vtable->iid = ndr_table_IWbemServices.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IEnumWbemClassObject generated by pidl */


static WERROR dcom_proxy_IEnumWbemClassObject_Reset(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct Reset r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;

	r.out.ORPCthat = talloc_zero(mem_ctx, struct ORPCTHAT);
#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(Reset, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IEnumWbemClassObject, NDR_RESET, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(Reset, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, uint32_t uCount, struct IWbemClassObject **apObjects, uint32_t *puReturned)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct IEnumWbemClassObject_Next r;
	struct MInterfacePointer* apObjects_mi = NULL;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;
	r.in.uCount = uCount;

	r.out.ORPCthat = talloc_zero(mem_ctx, struct ORPCTHAT);
	r.out.apObjects = &apObjects_mi;
#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(IEnumWbemClassObject_Next, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IEnumWbemClassObject, NDR_IENUMWBEMCLASSOBJECT_NEXT, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(IEnumWbemClassObject_Next, &r);
	}
#endif

	if (r.out.apObjects) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)apObjects, *r.out.apObjects));
	}
	*puReturned = *r.out.puReturned;

	return r.out.result;
}


static WERROR dcom_proxy_IEnumWbemClassObject_NextAsync(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, uint32_t uCount, struct IWbemObjectSink *pSink)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct NextAsync r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.uCount = uCount;
	r.in.pSink = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pSink) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pSink->obj, (struct IUnknown*)pSink));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(NextAsync, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IEnumWbemClassObject, NDR_NEXTASYNC, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(NextAsync, &r);
	}
#endif


	return r.out.result;
}


static WERROR dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, struct IEnumWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct IEnumWbemClassObject_Clone r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(IEnumWbemClassObject_Clone, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IEnumWbemClassObject, NDR_IENUMWBEMCLASSOBJECT_CLONE, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(IEnumWbemClassObject_Clone, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IEnumWbemClassObject_Skip(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, uint32_t nCount)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct Skip r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;
	r.in.nCount = nCount;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(Skip, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IEnumWbemClassObject, NDR_SKIP, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(Skip, &r);
	}
#endif


	return r.out.result;
}

NTSTATUS dcom_proxy_init_IEnumWbemClassObject(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IEnumWbemClassObject(TALLOC_CTX *ctx)
{
	struct IEnumWbemClassObject_vtable *proxy_vtable = talloc(ctx, struct IEnumWbemClassObject_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->Reset = dcom_proxy_IEnumWbemClassObject_Reset;
	proxy_vtable->IEnumWbemClassObject_Next = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next;
	proxy_vtable->NextAsync = dcom_proxy_IEnumWbemClassObject_NextAsync;
	proxy_vtable->IEnumWbemClassObject_Clone = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone;
	proxy_vtable->Skip = dcom_proxy_IEnumWbemClassObject_Skip;

	proxy_vtable->iid = ndr_table_IEnumWbemClassObject.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemLevel1Login generated by pidl */


static WERROR dcom_proxy_IWbemLevel1Login_EstablishPosition(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, uint16_t *wszLocaleList, uint32_t dwNumLocales, uint32_t *reserved)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct EstablishPosition r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.wszLocaleList = (const char*)wszLocaleList;
	r.in.dwNumLocales = dwNumLocales;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(EstablishPosition, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemLevel1Login, NDR_ESTABLISHPOSITION, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(EstablishPosition, &r);
	}
#endif

	*reserved = *r.out.reserved;

	return r.out.result;
}


static WERROR dcom_proxy_IWbemLevel1Login_RequestChallenge(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, uint16_t *wszNetworkResource, uint16_t *wszUser, uint8_t *Nonce)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct RequestChallenge r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.wszNetworkResource = (const char*)wszNetworkResource;
	r.in.wszUser = (const char*)wszUser;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(RequestChallenge, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemLevel1Login, NDR_REQUESTCHALLENGE, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(RequestChallenge, &r);
	}
#endif

	*Nonce = *r.out.Nonce;

	return r.out.result;
}


static WERROR dcom_proxy_IWbemLevel1Login_WBEMLogin(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, uint16_t *wszPreferredLocale, uint8_t *AccessToken, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemServices **ppNamespace)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct WBEMLogin r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.wszPreferredLocale = (const char*)wszPreferredLocale;
	r.in.AccessToken = AccessToken;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(WBEMLogin, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemLevel1Login, NDR_WBEMLOGIN, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(WBEMLogin, &r);
	}
#endif

	if (r.out.ppNamespace) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppNamespace, *r.out.ppNamespace));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemLevel1Login_NTLMLogin(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, uint16_t *wszNetworkResource, uint16_t *wszPreferredLocale, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemServices **ppNamespace)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct NTLMLogin r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.wszNetworkResource = (const char*)wszNetworkResource;
	r.in.wszPreferredLocale = (const char*)wszPreferredLocale;
	r.in.lFlags = lFlags;
	r.in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pCtx) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pCtx->obj, (struct IUnknown*)pCtx));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(NTLMLogin, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemLevel1Login, NDR_NTLMLOGIN, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(NTLMLogin, &r);
	}
#endif

	if (r.out.ppNamespace) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppNamespace, *r.out.ppNamespace));
	}

	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemLevel1Login(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemLevel1Login(TALLOC_CTX *ctx)
{
	struct IWbemLevel1Login_vtable *proxy_vtable = talloc(ctx, struct IWbemLevel1Login_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->EstablishPosition = dcom_proxy_IWbemLevel1Login_EstablishPosition;
	proxy_vtable->RequestChallenge = dcom_proxy_IWbemLevel1Login_RequestChallenge;
	proxy_vtable->WBEMLogin = dcom_proxy_IWbemLevel1Login_WBEMLogin;
	proxy_vtable->NTLMLogin = dcom_proxy_IWbemLevel1Login_NTLMLogin;

	proxy_vtable->iid = ndr_table_IWbemLevel1Login.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemWCOSmartEnum generated by pidl */


static WERROR dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next(struct IWbemWCOSmartEnum *d, TALLOC_CTX *mem_ctx, struct GUID *gEWCO, uint32_t lTimeOut, uint32_t uCount, uint32_t *puReturned, uint32_t *pSize, uint8_t **pData)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct IWbemWCOSmartEnum_Next r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.gEWCO = gEWCO;
	r.in.lTimeOut = lTimeOut;
	r.in.uCount = uCount;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(IWbemWCOSmartEnum_Next, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemWCOSmartEnum, NDR_IWBEMWCOSMARTENUM_NEXT, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(IWbemWCOSmartEnum_Next, &r);
	}
#endif

	*puReturned = *r.out.puReturned;
	*pSize = *r.out.pSize;
	*pData = *r.out.pData;

	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemWCOSmartEnum(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemWCOSmartEnum(TALLOC_CTX *ctx)
{
	struct IWbemWCOSmartEnum_vtable *proxy_vtable = talloc(ctx, struct IWbemWCOSmartEnum_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->IWbemWCOSmartEnum_Next = dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next;

	proxy_vtable->iid = ndr_table_IWbemWCOSmartEnum.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemFetchSmartEnum generated by pidl */


static WERROR dcom_proxy_IWbemFetchSmartEnum_Fetch(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx, struct IWbemWCOSmartEnum **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct Fetch r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(Fetch, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemFetchSmartEnum, NDR_FETCH, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(Fetch, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemFetchSmartEnum_Test(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx, struct IWbemClassObject **ppEnum)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct Test r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(Test, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemFetchSmartEnum, NDR_TEST, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(Test, &r);
	}
#endif

	if (r.out.ppEnum) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppEnum, *r.out.ppEnum));
	}

	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemFetchSmartEnum(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemFetchSmartEnum(TALLOC_CTX *ctx)
{
	struct IWbemFetchSmartEnum_vtable *proxy_vtable = talloc(ctx, struct IWbemFetchSmartEnum_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->Fetch = dcom_proxy_IWbemFetchSmartEnum_Fetch;
	proxy_vtable->Test = dcom_proxy_IWbemFetchSmartEnum_Test;

	proxy_vtable->iid = ndr_table_IWbemFetchSmartEnum.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemCallResult generated by pidl */


static WERROR dcom_proxy_IWbemCallResult_GetResultObject(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, struct IWbemClassObject **ppResultObject)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetResultObject r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetResultObject, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemCallResult, NDR_GETRESULTOBJECT, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetResultObject, &r);
	}
#endif

	if (r.out.ppResultObject) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppResultObject, *r.out.ppResultObject));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemCallResult_GetResultString(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, struct BSTR *pstrResultString)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetResultString r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetResultString, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemCallResult, NDR_GETRESULTSTRING, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetResultString, &r);
	}
#endif

	*pstrResultString = *r.out.pstrResultString;

	return r.out.result;
}


static WERROR dcom_proxy_IWbemCallResult_GetResultServices(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, struct IWbemServices **ppServices)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetResultServices r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetResultServices, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemCallResult, NDR_GETRESULTSERVICES, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetResultServices, &r);
	}
#endif

	if (r.out.ppServices) {
		WERROR_CHECK(dcom_IUnknown_from_MIP(d->ctx, (struct IUnknown**)ppServices, *r.out.ppServices));
	}

	return r.out.result;
}


static WERROR dcom_proxy_IWbemCallResult_GetCallStatus(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, int32_t *plStatus)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct GetCallStatus r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lTimeout = lTimeout;

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(GetCallStatus, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemCallResult, NDR_GETCALLSTATUS, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(GetCallStatus, &r);
	}
#endif

	*plStatus = *r.out.plStatus;

	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemCallResult(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemCallResult(TALLOC_CTX *ctx)
{
	struct IWbemCallResult_vtable *proxy_vtable = talloc(ctx, struct IWbemCallResult_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->GetResultObject = dcom_proxy_IWbemCallResult_GetResultObject;
	proxy_vtable->GetResultString = dcom_proxy_IWbemCallResult_GetResultString;
	proxy_vtable->GetResultServices = dcom_proxy_IWbemCallResult_GetResultServices;
	proxy_vtable->GetCallStatus = dcom_proxy_IWbemCallResult_GetCallStatus;

	proxy_vtable->iid = ndr_table_IWbemCallResult.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemObjectSink generated by pidl */


static WERROR dcom_proxy_IWbemObjectSink_SetStatus(struct IWbemObjectSink *d, TALLOC_CTX *mem_ctx, int32_t lFlags, WERROR hResult, struct BSTR strParam, struct IWbemClassObject *pObjParam)
{
	struct dcerpc_binding_handle *h;
	NTSTATUS status = dcom_binding_handle(d->ctx, &d->obj, &d->vtable->iid, &h);
	struct SetStatus r;

	// struct rpc_request *req;

	if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}

	NDR_ZERO_STRUCT(r.in);
	r.in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
	r.in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
    r.in.ORPCthis.cid = d->obj.iid;
	r.in.lFlags = lFlags;
	r.in.hResult = hResult;
	r.in.strParam = strParam;
	r.in.pObjParam = talloc_zero(mem_ctx, struct MInterfacePointer);
	if (pObjParam) {
		WERROR_CHECK(dcom_OBJREF_from_IUnknown(mem_ctx, &r.in.pObjParam->obj, (struct IUnknown*)pObjParam));
	}

#if 0
	if (h->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(SetStatus, &r);
	}
#endif
	status = dcerpc_binding_handle_call(h, &d->obj.u_objref.u_standard.std.ipid, &ndr_table_IWbemObjectSink, NDR_SETSTATUS, mem_ctx, &r);
    if (NT_STATUS_IS_ERR(status)) {
		return W_ERROR(NT_STATUS_V(status));
	}
#if 0
	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(SetStatus, &r);
	}
#endif


	return r.out.result;
}

NTSTATUS dcom_proxy_init_IWbemObjectSink(TALLOC_CTX *ctx);
NTSTATUS dcom_proxy_init_IWbemObjectSink(TALLOC_CTX *ctx)
{
	struct IWbemObjectSink_vtable *proxy_vtable = talloc(ctx, struct IWbemObjectSink_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = ndr_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}

	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->SetStatus = dcom_proxy_IWbemObjectSink_SetStatus;

	proxy_vtable->iid = ndr_table_IWbemObjectSink.syntax_id.uuid;

	return dcom_register_proxy(ctx, (struct IUnknown_vtable *)proxy_vtable);
}
